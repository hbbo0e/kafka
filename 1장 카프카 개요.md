
서비스 품질 개선 등 기업에서의 데이터 처리의 복잡성 해결과 실시간 처리에 대한 요구에 강함

카프카 => 아파치 카프카
컨틀루언트 카프카 => 컨플루언트에서 제공하는 카프카

# 1.1 잘란도와 트위터의 카프카 도입 사례

> 비동기 방식의 대표 스트리밍 플랫폼, 카프카 도입

카프카가 잘란도의 대안으로 떠오른 이유는 **높은 처리량, 순서보장, 적어도 한 번 전송 방식, 강력한 파티셔닝, 자연스러운 백프레셔 핸들링, 로그 컴팩션** 같은 훌륭한 기능들 때문이었다.

**1. 빠른 데이터 수집이 가능한 높은 처리량**

**2. 순서보장**
	이벤트 처리 순서가 보장되면서 엔티티 간의 유효성 검사나 동시 수정 같은 무수한 복잡성들이 제거됨으로써 구조 또한 간결해졌다.

**3. 적어도 한 번 전송 방식**
	분산된 여러 네트워크 환경에서의 데이터 처리에서 중요한 모범 사례는 ==멱등성==이다. (동일한 작업을 여러 번 수행하더라도 결과가 달라지지 않는 것을 의미한다.)
	간혹 이벤트들이 중복 발생할 수는 있으나 누락 없는 재전송이 가능하여 메시지 손실에 대한 걱정이 사라진다.
	백엔드 시스템들이 중복 메시지 처리가 가능하도록 허용된다면 복잡한 트랜잭션 처리 또한 필요하지 않게 된다.

**4. 자연스러운 백프레셔 핸들링**
	카프카의 클라이언트는 자기 자신의 속도로 데이터를 처리할 수 있는 pull (풀) 방식으로 동작한다. 
	push (푸쉬) 방식은 브로커가 보내주는 속도에 의존해야 한다는 한계가 있다.
	==백프레셔 핸들링== : 소비자의 처리 능력이 생산자의 메시지 전송 속도를 따라가지 못할 때 발생하는 문제를 해결하기 위한 방법이다. 

**5. 강력한 파티셔닝**
	논리적으로 토픽을 여러 개로 나눌 수 있다. 각 파티션들을 다른 파티션들과 관계없이 처리할 수 있으므로 효과적인 수평 확장이 가능하다.

**6. 그 외 여러가지 기능**
	로그 컴팩션 기능 -> 스냅샷 역할, 새로운 애플리케이션이 나중에 메시지를 읽어가는 방식도 문제되지 않음
	프로듀서와 컨슈머가 완벽하게 분리된 비동기식 방식을 사용하여 ==애플리케이션의 병목 현상을 정확하게 파악할 수 있고, 모니터링을 통해 지연에 대한 문제를 빠르게 해결할== 수 있다.



# 1.2 국내외 카프카 이용 현황

# 1.3 카프카의 주요 특징

## 1. 높은 처리량과 낮은 지연시간

![[Pasted image 20240613172926.png]]

엔터프라이즈 환경의 기업들은 예측할 수 없이 늘어나는 데이터 처리를 위해 처리량이 높은 시스템을 선호하게 된다.
카프카, 펄사, 래빗MQ 성능을 비교하였는데 처리량이 가장 높은 것은 카프카로 응답 속도가 가장 빠른 것은 래빗MQ 이다.
하지만, 처리량과 응답 속도를 같이 비교하면 카프카가 단연 독보적인 것을 확인할 수 있다.

- 펄사 ?
	: apache 산하의 오픈소스로 야후에서 개발한 메시징 시스템
	카프카와 유사하게 분산 시스템 구조를 갖고 잇는 펍/섭 (pub/sub) 형태의 메시징 애플리케이션이다.

## 2. 높은 확장성

만약 기업의 비즈니스가 급속도로 성장하는 중에 중앙 데이터 파이프라인을 담당하는 시스템의 성능 한계로 인해 더이상 확장할 수 없다면 이는 비즈니스의 성공을 가로막는 걸림돌이 될 것이다. 
또한, 아무리 뛰어난 관리자일지라도 미래의 상황을 정확하게 예측해 시스템을 설꼐하기에는 한계가 있다.

--> 카프카는 이러한 요구사항들을 충족시켜줄 수 잇도록 손쉽게 확장 가능하도록 설계되어 있다.

## 3. 고가용성

2013년 클러스터 내 리플리케이션 기능을 추가했고 이를 통해 카프카 클러스터의 고가용성이 확보되었다.

- ==고가용성 ?== 
	: 클러스터의 일부 노드나 컴포넌트가 장애를 일으키더라도 시스템이 지속적으로 운영될 수 있도록 하는 매커니즘과 설계 방식을 의미한다. 
	- 장점
	 1) 일부 브로커나 리플리카에 장애가 발생하더라도 카프카 클러스터는 지속적으로 데이터를 처리할 수 있다.
	 2) 리플리케이션을 통해 데이터가 여러 브로커에 복제되므로, 데이터 손실 위험이 최소화된다.
	 3) 장애 발생 시 자동으로 클러스터를 재조정하여 문제를 해결하므로 관리 부담이 줄어든다.
	 4) 고가용성을 유지하면서도 클러스터를 손쉽게 확장할 수 있다.

- ==리플리케이션 ?==
	: 데이터의 내구성과 가용성을 보장하기 위해 메시지를 여러 브로커에 복제하는 매커니즘이다.
	-> 카프카 클러스터가 일부 브로커의 장애에도 불구하고 데이터 손실 없이 지속적으로 운영될 수 있도록 한다.
	- 장점
	 1) 데이터가 여러 브로커에 복제되므로, 일부 브로커가 장애가 발생해도 데이터가 손실되지 않는다.
	 2) 리플리카 간의 자동 장애 복구 기능으로 인해 시스템의 가용성이 높아진다.
	 3) 카프카 클러스터는 리플리카를 통해 부하를 분산시켜 높은 처리량을 유지할 수 있다.


## 4. 내구성

`프로듀서` 는 카프카로 메시지를 전송할 때, 프로듀서의 `acks` 라는 옵션을 조정하여 메시지의 내구성을 강화할 수 있다. 강력한 메시지의 내구성을 원한다면 옵션을 `acks=all` 로 사용할 수 있다.

전통적인 메시징 시스템의 경우, 컨슈머가 메시지를 가져감과 동시에 저장소에서 메시지가 삭제되는데, 카프카는 `컨슈머`가 메시지를 가져가더라도 삭제되지 않고 지정된 설정 시간 또는 로그의 크기만큼 로컬 디스크에 보관된다. 그러므로 코드의 버그나 장애가 발생하더라도 과거의 메시지를 불러와 재처리할 수 있다.


## 5. 개발 편의성

`프로듀서` : 메시지를 전송하는 역할
`컨슈머` : 메시지를 가져오는 역할

이 둘은 완벽하게 분리되어 동작하고 서로 영향을 주지도 않는다. 프로듀서와 컨슈머를 동시에 사용할 때는 워크로드 또는 구현하고자 하는 요구사항에 따라 프로듀서와 컨슈머에서 제공하는 옵션을 잘 활용해야 한다.

개발 편의성을 제공하기 위해 카프카에서는 카프카 커넥트와 스키마 레지스트리를 제공한다.
	==스키마 레지스트리는== 카프카를 사용하는 많은 개발자가 데이터 활용보다는 데이터를 파싱하는데 많은 시간을 소모하는 비효율적인 현실을 보완하고자 스키마를 정의해서 사용할 수 있도록 개발된 애플리케이션이다.
	==카프카 커넥트==는 프로듀서와 컨슈머를 따로 개발하지 않고도 카프카와 연동해 손쉽게 소스와 싱크로 데이터를 보내고 받을 수 있는 별도의 애플리케이션이다. 


## 6. 운영 및 관리 편의성

한 시스템에서 중요한 역할을 하는 애플리케이션이라면 성능 확장을 위한 증설 작업이 쉽고 간단해야 하며, 최신 버전이 릴리스 되는 경우 무중단으로 버전 업그레이드도 가능해야 하고 작업도 간단해야 한다.



# 1.4 카프카의 성장

## 리플리케이션 기능 추가 (v 0.8)

내부 카프카 클러스터에서 브로커의 장애가 발생해도 리플리케이션 기능으로 인해 데이터 유실 없이 안정적으로 사용할 수 있게 됐다.

## 스키마 레지스트리 공개 (v 0.8.2)

프로듀서와 컨슈머 간에 서로 데이터 구조를 설명할 수 있는 스키마를 등록 지정해 사용하는 스키마 레지스트리가 발표되었다.
-> 이 스키마 레지스트리를 이용해 스키마를 등록할 수 있고 이를 통해 스키마에 정의된 데이터만 주고받게 된다.

## 카프카 커넥트 공개 (v 0.9)

프로듀서 클라이언트의 장애 처리, 유지보수 등과 같은 문제는 직접 해결해야 하고, 기업들이 카프카를 활용해 데이터를 통합하거나 데이터 허브로 이용하는 경우가 많아지면서 카프카와 연결되는 시스템이 다양해졌다.
이러한 시스템들과 카프카를 하나하나 연동하는 클라이언트를 개발하고 유지보수 하는 에러사항을 해결하기 위해 카프카 커넥트를 공개하게 되었다.

이로써 별도의 코드 작성 없이도 다양한 프로토콜과 카프카를 연동할 수 있게 됐다.

## 카프카 스트림즈 공개 (v 0.10)

실시간 처리에 대한 니즈를 충족시키고자 카프카 스트림즈를 공개했고 간단하고 가벼운 클라이언트를 이용해 많은 개발자나 기업에서의 실시간 분석과 처리가 가능해졌다.

## KSQL 공개

개발자들이 별도의 코드를 작성하지 않고도 익숙한 SQL 기반으로 실시간 처리 가능한 KSQL 이 공개되었다.
이를 이용하면 스트림 처리 뿐만 아니라 배치 처리도 가능하다.

## 주키퍼 의존성에서 해방 (v 3.0)

지금까지는 카프카의 토픽, 브로커 등을 관리하는 목적으로 분산 코디네이터 시스템인 주키퍼를 사용해왔으나 이는 카프카의 높은 성능에 방해가 됐었다.
그래서 주키퍼 없이 동작 가능한 카프카가 공개되었고, 아직은 실제 운영 환경에서 사용하는 것을 추천하지는 않는다. 

그리고, 프로듀서의 전송 보장에 대해 중복 없는 전송 (멱등성) 방식을 기본값으로 채택했고 컨슈머의 `session.timeout.ms` 기본값을 늘려 컨슈머의 안정성을 높였다.



# 1.5 다양한 카프카의 사용 사례

